%{
/*

Copyright (C) 2015, cPanel Inc

=head1 NAME

ext/warnings/warnings.xs - gperf generated read-only warnings hash as shared library

=head1 DESCRIPTION

Generated warnings hash from F<ext/warnings/warnings_xs.in> via F<ext/warnings/warnings_xs.PL>

C<gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in>
with cleanup for header, inline, C++ and c89.

The hashes C<%Bits>, C<%DeadBits> are tied to the the values in the
const wordlist perfect hash.  Only the C<all> key is writable, but the
hash is extendable.  Every read-access goes first through the perfect
hash, and then into a normal perl hash, to be able to register custom
user-categories. We assume almost nobody needs to create his own user
category, so penalize this.

=over 4

=item C<struct Perl_warnings>

Generated read-only hash table with name, offsets, bits and deadbits.

=back

=head2 Functions

=over 4

=item C<const struct Perl_warnings * Perl_warnings_lookup(register const
char *str, register unsigned int len)>

Generated lookup function.

=back

=cut

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "warnings.h"

#define WNORMAL  1
#define WFATAL   2
#define WMESSAGE 4

#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)

const struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len);

static int _chk(const char *sub, U32 flags, I32 ax) {
    dSP;
    SV **mark = PL_stack_base + ax - 1;
    dITEMS;
    SV *message, *mask;
    char *category;
    int i, is_obj = 0;
    struct Perl_warnings *w;
    int has_message = flags & WMESSAGE;
    int results_0 = 0, results_1 = 0;

    if (!(items == 1 || items == (has_message ? 2 : 0))) {
        SV *msg = newSVpvs("");
        sv_catpvf(msg, "Usage %s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
        croak_sv(carp_shortmess(ax, msg));
        /*croak("Usage %s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");*/
    }
    if (has_message) {
        message = ST(1);
        if (DEBUG_v_TEST_)
            Perl_deb("warnings::%s \"%s\"\n", sub, SvPVX(message));
    }
    if (items > 0) {
        if (SvOBJECT(ST(0))) {
            category = HvNAME(SvSTASH(ST(0)));
            is_obj = 1;
        } else if (SvPOK(ST(0))) {
            category = SvPVX(ST(0));
        } else {
            croak_sv(carp_shortmess(ax, newSVpvs("not an object")));
        }
    } else {
        category = HvNAME(CopSTASH(PL_curcop));
    }
    if (DEBUG_v_TEST_)
        Perl_deb("warnings::%s category=%s\n", sub, category);

    w = Perl_warnings_lookup(category, strlen(category));
    if (!w) {
        SV *msg = newSVpvs("");
        if (items > 0)
            sv_catpvf(msg, "Unknown warnings category '%s'", category);
        else
            sv_catpvf(msg, "package '%s' not registered for warnings", category);
        croak_sv(carp_shortmess(ax, msg));
    }
    if (is_obj) {
        /* TODO: walk the callstack and find category */
        i = 0;
    } else {
        i = short_error_loc();
    }
    {
        const PERL_CONTEXT *cx = caller_cx(i, NULL);
        if (cx) {
            STRLEN * const old_warnings = cx->blk_oldcop->cop_warnings;

            if  (old_warnings == pWARN_NONE)
                mask = newSVpvn(WARN_NONEstring, WARNsize);
            else if (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0)
                mask = &PL_sv_undef;
            else if (old_warnings == pWARN_ALL ||
                     (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON)) {
                /* XXX depends on register_categories().
                   if extended get the extended all mask. */
                SV **bits_all;
                HV * const bits = get_hv("warnings::Bits", 0);
                if (bits && ((bits_all = hv_fetchs(bits, "all", FALSE)))) {
                    mask = newSVsv(*bits_all);
                }
                else {
                    mask = newSVpvn(WARN_ALLstring, WARNsize);
                }
            }
            else
                mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
        } else {
            mask = newSVpvn(WARN_DEFAULTstring, WARNsize);
        }
    }
    if (DEBUG_v_TEST_) {
        SV *dsv = newSVpvs("");
        pv_pretty( dsv, SvPVX(mask), SvCUR(mask), 80, NULL, NULL, PERL_PV_PRETTY_DUMP);
        Perl_deb("warnings::%s depth=%d, mask=%s\n", sub, i, SvPVX(dsv));
        SvREFCNT_dec(dsv);
    }
    if (flags & WFATAL) {
        const char* m = SvPVX(mask);
        results_0 = (int)m[w->offset + WFATAL - 1];
        if (!results_0) results_0 = (int)m[WFATAL - 1];
    }
    if (flags & WNORMAL) {
        const char* m = SvPVX(mask);
        results_1 = (int)m[w->offset + WNORMAL - 1];
        if (!results_1) results_1 = (int)m[WNORMAL - 1];
    }
    /* &enabled and &fatal_enabled */
    if (!has_message)
        return results_0 ? results_0 : results_1;
    /* &warnif, and the category is neither enabled as warning nor as fatal */
    if (flags == (WNORMAL | WFATAL | WMESSAGE) && !(results_0 | results_1))
        return 0;
    if (results_0)
        croak_sv(carp_longmess(ax, message));
    /* will always get here for &warn. will only get here for &warnif if the
       category is enabled */
    warn_sv(carp_shortmess(ax, message));
    return 1;
}

%}
%language=ANSI-C
%struct-type
%define hash-function-name   Perl_warnings_hash
%define lookup-function-name Perl_warnings_lookup
%readonly-tables
%null-strings
%pic

struct Perl_warnings { int name; const unsigned char offset; const char* bits; const char* deadbits; };
%%
all, 0, "\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55", "\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"
closure, 2, "\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
deprecated, 4, "\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
exiting, 6, "\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
glob, 8, "\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
io, 10, "\x00\x54\x55\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00", "\x00\xa8\xaa\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00"
closed, 12, "\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
exec, 14, "\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
layer, 16, "\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
newline, 18, "\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
pipe, 20, "\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
unopened, 22, "\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
misc, 24, "\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
numeric, 26, "\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
once, 28, "\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
overflow, 30, "\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
pack, 32, "\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
portable, 34, "\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
recursion, 36, "\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
redefine, 38, "\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
regexp, 40, "\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
severe, 42, "\x00\x00\x00\x00\x00\x54\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\xa8\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
debugging, 44, "\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
inplace, 46, "\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
internal, 48, "\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
malloc, 50, "\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
signal, 52, "\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
substr, 54, "\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
syntax, 56, "\x00\x00\x00\x00\x00\x00\x00\x55\x55\x15\x00\x40\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\xaa\xaa\x2a\x00\x80\x00\x00\x00\x00\x00"
ambiguous, 58, "\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00"
bareword, 60, "\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00\x00"
digit, 62, "\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00"
parenthesis, 64, "\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x00"
precedence, 66, "\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00"
printf, 68, "\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x00"
prototype, 70, "\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00"
qw, 72, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00"
reserved, 74, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00"
semicolon, 76, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00"
taint, 78, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00"
threads, 80, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00"
uninitialized, 82, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00"
unpack, 84, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00"
untie, 86, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00"
utf8, 88, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x15\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x2a\x00\x00\x00\x00"
void, 90, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00"
imprecision, 92, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00"
illegalproto, 94, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00"
non_unicode, 96, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00"
nonchar, 98, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00"
surrogate, 100, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00"
experimental, 102, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x55\x15\x55\x01", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\xaa\x2a\xaa\x02"
experimental::lexical_subs, 104, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00"
experimental::lexical_topic, 106, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00"
experimental::regex_sets, 108, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00"
experimental::smartmatch, 110, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00"
experimental::autoderef, 112, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00"
experimental::postderef, 114, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00"
experimental::signatures, 116, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00"
syscalls, 118, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00"
experimental::bitwise, 120, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00"
experimental::const_attr, 122, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\x00"
experimental::re_strict, 124, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00"
experimental::refaliasing, 126, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x00"
experimental::win32_perlio, 128, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02"
locale, 130, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08"
missing, 132, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20"
redundant, 134, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x40", "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80"
%%

MODULE = warnings		PACKAGE = warnings

SV*
bits (mask, ...)
   SV* mask
CODE:
    XSRETURN_UNDEF;

bool
enabled (...)
CODE:
    if (_chk("enabled", WNORMAL, ax))
      XSRETURN_YES;
    else
      XSRETURN_NO;

bool
fatal_enabled (...)
CODE:
    if (_chk("fatal_enabled", WFATAL, ax))
      XSRETURN_YES;
    else
      XSRETURN_NO;

bool
warn (...)
CODE:
    if (_chk("warn", WFATAL|WMESSAGE, ax))
      XSRETURN_YES;
    else
      XSRETURN_NO;

bool
warnif (...)
CODE:
    if (_chk("warnif", WNORMAL|WFATAL|WMESSAGE, ax))
      XSRETURN_YES;
    else
      XSRETURN_NO;

SV*
import (klass, ...)
   SV* klass
CODE:
    XSRETURN_UNDEF;

SV*
unimport (klass, ...)
   SV* klass
CODE:
    XSRETURN_UNDEF;

void
register_categories (...)
CODE:
    int i;
    /* check if name is registered (const key).
       if not, add key and also add bit to Bits{all} and DeadBits{all} */
    for (i=0; i<items; i++) {
        SV *name = ST(i);
        char* n;
        struct Perl_warnings *w;
        if (!SvPOK(name)) continue;
        n = SvPVX(name);
        w = Perl_warnings_lookup(n, SvCUR(name));
        if (!w) { /* oops, a new category. should be a very rare case */
            HV * const bits = get_hv("warnings::Bits", GV_ADD);
            if (DEBUG_v_TEST_)
                Perl_deb("warnings::register_categories %s\n", n);
            if (bits) {
                hv_stores(bits, "all", newSVpvn(WARN_ALLstring, WARNsize));
            }
        }
    }
    XSRETURN_UNDEF;
