%{
/*

Copyright (C) 2015, cPanel Inc

=head1 NAME

ext/warnings/warnings.xs - gperf generated read-only warnings hash as shared library

=head1 DESCRIPTION

Generated warnings hash from F<ext/warnings/warnings_xs.in> via F<ext/warnings/warnings_xs.PL>

C<gperf --output-file=ext/warnings/warnings.xs ext/warnings/warnings_xs.in>
with cleanups for header, inline, C++ and c89.

The hashes C<%Bits>, C<%DeadBits> are tied to the the values in the
const wordlist perfect hash.  Only the C<all> key is writable, but the
hash is extendable.  Every read-access goes first through the perfect
hash, and then into a normal perl hash, to be able to register custom
user-categories. We assume almost nobody needs to create his own user
category, so penalize this.

=over 4

=item C<struct Perl_warnings>

Structure of generated read-only hash table with name, offsets, bits and deadbits.

=back

=head2 Functions

=over 4

=item C<struct Perl_warnings * Perl_warnings_lookup(register const
char *str, register unsigned int len)>

API function to access the generated hash.

=item C<struct Perl_warnings * warnings_const_lookup(register const
char *str, register unsigned int len)>

Generated lookup function to access to read-only compile-time part of the hash.

=back

=cut

*/

#define PERL_NO_GET_CONTEXT
#define PERL_EXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "warnings.h"

#define WNORMAL  1
#define WFATAL   2
#define WMESSAGE 4

#define AV_PUSH(av, val) av_store(av, AvFILLp(av)+1, val)
#define newWSV(str) newSVpvn(str, WARN_MAX_BYTES)

struct Perl_warnings { int name; const unsigned char offset; const char *bits; const char *deadbits; };
struct Perl_warnings_dyn { int name; unsigned char offset; char *bits; char *deadbits; };
struct Perl_warnings_dyn ws;
struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len);

%}
%language=ANSI-C
%struct-type
%define hash-function-name   warnings_hash
%define lookup-function-name warnings_const_lookup
%null-strings
%pic

struct Perl_warnings;
%%
all, 0, "\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\125\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\252\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
closure, 2, "\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
deprecated, 4, "\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
exiting, 6, "\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
glob, 8, "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
io, 10, "\0\124\125\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\250\252\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
closed, 12, "\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
exec, 14, "\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
layer, 16, "\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
newline, 18, "\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
pipe, 20, "\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
unopened, 22, "\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
misc, 24, "\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
numeric, 26, "\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
once, 28, "\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
overflow, 30, "\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
pack, 32, "\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
portable, 34, "\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
recursion, 36, "\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
redefine, 38, "\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
regexp, 40, "\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
severe, 42, "\0\0\0\0\0\124\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\250\12\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
debugging, 44, "\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
inplace, 46, "\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
internal, 48, "\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
malloc, 50, "\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
signal, 52, "\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
substr, 54, "\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
syntax, 56, "\0\0\0\0\0\0\0\125\125\25\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\252\252\52\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
ambiguous, 58, "\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
bareword, 60, "\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
digit, 62, "\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
parenthesis, 64, "\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
precedence, 66, "\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
printf, 68, "\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
prototype, 70, "\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
qw, 72, "\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
reserved, 74, "\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
semicolon, 76, "\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
taint, 78, "\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
threads, 80, "\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
uninitialized, 82, "\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
unpack, 84, "\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
untie, 86, "\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
utf8, 88, "\0\0\0\0\0\0\0\0\0\0\0\1\25\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\2\52\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
void, 90, "\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
imprecision, 92, "\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
illegalproto, 94, "\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
non_unicode, 96, "\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
nonchar, 98, "\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
surrogate, 100, "\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental, 102, "\0\0\0\0\0\0\0\0\0\0\0\0\100\125\25\125\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\200\252\52\252\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::lexical_subs, 104, "\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::lexical_topic, 106, "\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::regex_sets, 108, "\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::smartmatch, 110, "\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::autoderef, 112, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::postderef, 114, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::signatures, 116, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
syscalls, 118, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::bitwise, 120, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::const_attr, 122, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::re_strict, 124, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::refaliasing, 126, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
experimental::win32_perlio, 128, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
locale, 130, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
missing, 132, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\40\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
redundant, 134, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\100\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\200\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
%%

struct Perl_warnings *
Perl_warnings_lookup (register const char *str, register unsigned int len) {
    const struct Perl_warnings *w = warnings_const_lookup(str, len);
    if (!w) {
        SV **bit;
        HV * const bits = get_hv("warnings::_Bits", 0);
        if (bits && ((bit = hv_fetch(bits, str, len, FALSE)))) {
            const char *p = SvPVX(*bit);
            struct Perl_warnings_dyn *w1 = &ws;
            STRLEN l = SvCUR(*bit) / 2;
            w1->offset   = SvIVX(*bit);
            w1->bits     = SvPVX(newSVpvn(p, l));
            w1->deadbits = SvPVX(newSVpvn(p + l, l));
            return (struct Perl_warnings *)w1;
        } else {
            return NULL;
        }
    }
    return (struct Perl_warnings *)w;
}

static int _chk(const char *sub, U32 flags, I32 ax) {
    dSP;
    SV **mark = PL_stack_base + ax - 1;
    dITEMS;
    SV *message, *mask;
    char *category;
    const struct Perl_warnings *w;
    const PERL_CONTEXT *cx;
    int i, is_obj = 0;
    int has_message = flags & WMESSAGE;
    int results_0 = 0, results_1 = 0;

    if (!(items == 1 || items == (has_message ? 2 : 0))) {
        SV *msg = newSVpvs("");
        sv_catpvf(msg, "Usage %s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");
        croak_sv(carp_shortmess(ax, msg));
        /*croak("Usage %s(%s)", sub, has_message ? "[category,] 'message'" : "[category]");*/
    }
    if (has_message) {
        message = ST(1);
        if (DEBUG_v_TEST_)
            Perl_deb("warnings::%s \"%s\"\n", sub, SvPVX(message));
    }
    if (items > 0) {
        if (SvOBJECT(ST(0))) {
            category = HvNAME(SvSTASH(ST(0)));
            is_obj = 1;
        } else if (SvPOK(ST(0))) {
            category = SvPVX(ST(0));
        } else {
            croak_sv(carp_shortmess(ax, newSVpvs("not an object")));
        }
    } else {
        category = HvNAME(CopSTASH(PL_curcop));
    }
    if (DEBUG_v_TEST_)
        Perl_deb("warnings::%s category=%s\n", sub, category);

    w = Perl_warnings_lookup(category, strlen(category));
    if (!w) {
        SV *msg = newSVpvs("");
        if (items > 0)
            sv_catpvf(msg, "Unknown warnings category '%s'", category);
        else
            sv_catpvf(msg, "package '%s' not registered for warnings", category);
        croak_sv(carp_shortmess(ax, msg));
    }

    if (is_obj) {
        /* TODO: walk the callstack and find category */
        i = 0;
    } else {
        i = short_error_loc();
    }
    if ((cx = caller_cx(i, NULL))) {
        STRLEN * const old_warnings = cx->blk_oldcop->cop_warnings;

        if  (old_warnings == pWARN_NONE)
            mask = newWSV(WARN_NONEstring);
        else if (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0)
            mask = &PL_sv_undef;
        else if (old_warnings == pWARN_ALL ||
                 (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON)) {
          /* depends on register_categories(). See below.
             if extended, get the extended all mask. */
          HV * const bits = get_hv("warnings::_Bits", 0);
          if (bits) {
            w = Perl_warnings_lookup("all", 3);
            mask = newWSV(w->bits);
          }
          else {
            mask = newWSV(WARN_ALLstring);
          }
        }
        else {
            mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
        }
    } else {
        mask = newWSV(WARN_DEFAULTstring);
    }
    if (DEBUG_v_TEST_) {
      SV *dsv = newSVpvn("", 80);
        pv_pretty( dsv, SvPVX(mask), SvCUR(mask), 80, NULL, NULL, PERL_PV_PRETTY_DUMP);
        Perl_deb("warnings::%s depth=%d, mask=%s\n", sub, i, SvPVX(dsv));
        SvREFCNT_dec(dsv);
    }
    if (flags & WFATAL) {
        const char* m = SvPVX(mask);
        results_0 = (int)m[w->offset + WFATAL - 1];
        if (!results_0) results_0 = (int)m[WFATAL - 1];
    }
    if (flags & WNORMAL) {
        const char* m = SvPVX(mask);
        results_1 = (int)m[w->offset + WNORMAL - 1];
        if (!results_1) results_1 = (int)m[WNORMAL - 1];
    }
    /* &enabled and &fatal_enabled */
    if (!has_message)
        return results_0 ? results_0 : results_1;
    /* &warnif, and the category is neither enabled as warning nor as fatal */
    if (flags == (WNORMAL | WFATAL | WMESSAGE) && !(results_0 | results_1))
        return 0;
    if (results_0)
        croak_sv(carp_longmess(ax, message));
    /* will always get here for &warn. will only get here for &warnif if the
       category is enabled */
    warn_sv(carp_shortmess(ax, message));
    return 1;
}

MODULE = warnings		PACKAGE = warnings

void
_bits (mask, ...)
     SV *mask
PREINIT:
    int i;
    int fatal = 0, no_fatal = 0;
    const struct Perl_warnings *w;
PPCODE:
    if (!SvPOK(mask))
        mask = newWSV(WARN_NONEstring);
    for (i=0; i<items; i++) {
        SV *word = ST(i);
        if (SvPOK(word)) {
            if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) {
                fatal = 1;
                no_fatal = 0;
            } else
            if (memEQs(SvPVX(word), SvCUR(word), "NONFATAL")) {
                fatal = 0;
                no_fatal = 1;
            } else
            if ((w = Perl_warnings_lookup(SvPVX(word), SvCUR(word)))) {
                const char *catmask = w->bits;
                do_vop(OP_BIT_OR, mask, mask, newWSV(catmask));
                if (fatal)
                    do_vop(OP_BIT_OR, mask, mask, newWSV(w->deadbits));
                if (no_fatal) {
                    U8 *p;
                    STRLEN j;
                    SV *tmp = newWSV("");
                    do_vop(OP_BIT_OR, tmp, newWSV(w->deadbits), newWSV(WARN_ALLstring));
                    /* scomplement is static */
                    for (p=(U8*)SvPVX(tmp), j=0; j<SvCUR(tmp); j++) {
                        const U8 c = *p;
                        *p++ = ~c;
                    }
                    do_vop(OP_BIT_AND, mask, tmp, mask);
                }
            }
        }
    }
    TOPs = mask;
    XSRETURN(1);

void
bits (...)
PPCODE:
    PUSHs(&PL_sv_undef);
    if (!items)
        PUSHs(newSVpvs("all"));
    if (call_pv("warnings::_bits", G_SCALAR))
        XSRETURN(1);
    else
        XSRETURN_UNDEF;

void
import (klass, ...)
    SV* klass
PREINIT:
    SV *mask;
    char *b;
    const struct Perl_warnings *w_all = Perl_warnings_lookup("all", 3);
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (PL_curcop->cop_warnings == pWARN_NONE)
        mask = newWSV(WARN_DEFAULTstring);
    else if (specialWARN(PL_curcop->cop_warnings))
        mask = newWSV(WARN_ALLstring);
    else
        mask = newSVpvn((char*)((STRLEN*)PL_curcop->cop_warnings+1), *PL_curcop->cop_warnings);
    b = SvPVX(mask);
    if (IsSet(b, 0)) {
        do_vop(OP_BIT_OR, mask, mask, newWSV(w_all->bits));
        if (IsSet(SvPVX(mask), 1))
            do_vop(OP_BIT_OR, mask, mask, newWSV(w_all->deadbits));
    }
    if (items) {
        PUSHs(mask);
        /* push @_, 'all' if @_==1 && ( $_[0] eq 'FATAL' || $_[0] eq 'NONFATAL' ); */
        if (items == 1 && (SvPOK(ST(0))
                           && (memEQs(SvPVX(ST(0)), SvCUR(ST(0)), "FATAL")
                               || memEQs(SvPVX(ST(0)), SvCUR(ST(0)), "NONFATAL"))))
            PUSHs(newSVpvs("all"));
        /* ${^WARNING_BITS} = @_ ? _bits($mask, @_) : $mask | $Bits{all} ; */
        if (call_pv("warnings::_bits", G_SCALAR)) {
            PL_compiling.cop_warnings
                = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                        SvPVX(TOPs), SvCUR(TOPs));
            if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
                PL_dowarn |= G_WARN_ONCE ;
            XSRETURN(1);
        } else
            XSRETURN_UNDEF;
    } else {
        do_vop(OP_BIT_OR, mask, mask, newWSV(w_all->bits));
        PL_compiling.cop_warnings
            = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                    SvPVX(mask), SvCUR(mask));
        if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
            PL_dowarn |= G_WARN_ONCE ;
        mXPUSHs(mask);
        XSRETURN(1);
    }

void
unimport (klass, ...)
   SV* klass
PREINIT:
    SV *mask;
    char *b;
    int i;
    const struct Perl_warnings *w_all = Perl_warnings_lookup("all", 3);
PPCODE:
    if (!SvPOK(klass))
        croak_xs_usage(cv,  "class, ...");
    /* mask = ${^WARNING_BITS} // ($^W ? $Bits{all} : $DEFAULT); */
    if (PL_curcop->cop_warnings == pWARN_NONE)
        mask = newWSV(WARN_DEFAULTstring);
    else if (specialWARN(PL_curcop->cop_warnings))
        mask = newWSV(WARN_ALLstring);
    else
        mask = newSVpvn((char*)((STRLEN*)PL_curcop->cop_warnings+1), *PL_curcop->cop_warnings);
    b = SvPVX(mask);
    if (IsSet(b, 0)) {
        do_vop(OP_BIT_OR, mask, mask, newWSV(w_all->bits));
        if (IsSet(SvPVX(mask), 1))
            do_vop(OP_BIT_OR, mask, mask, newWSV(w_all->deadbits));
    }
    /* push @_, 'all' if !@_ || @_==1 && $_[0] eq 'FATAL'; */
    if ((items == 0) || (items == 1 && (SvPOK(ST(0)) && memEQs(SvPVX(ST(0)), SvCUR(ST(0)), "FATAL")))) {
        PUSHs(newSVpvs("all"));
        items++;
    }
    for (i=0; i<items; i++) {
        SV *word = ST(i);
        if (!SvPOK(word)) continue;
        if (memEQs(SvPVX(word), SvCUR(word), "FATAL")) continue;
        else {
            const struct Perl_warnings *w = Perl_warnings_lookup(SvPVX(word), SvCUR(word));
            if (w) { /* $mask &= ~($catmask | $DeadBits{$word} | $All); */
                STRLEN j; U8 *p;
                SV *catmask = newWSV(w->bits);
                do_vop(OP_BIT_OR, catmask, catmask, newWSV(w->deadbits));
                do_vop(OP_BIT_OR, catmask, catmask, newWSV("\3")); /* $All */
                for (p=(U8*)SvPVX(catmask), j=0; j<SvCUR(catmask); j++) {
                    const U8 c = *p;
                    *p++ = ~c;
                }
                do_vop(OP_BIT_AND, mask, mask, catmask);
            } else {
                SV *msg = newSVpvs("Unknown warnings category '");
                sv_catsv(msg, word);
                sv_catpvs(msg, "'");
                croak_sv(carp_shortmess(ax, msg));
            }
        }
    }
    PL_compiling.cop_warnings
            = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
                                    SvPVX(mask), SvCUR(mask));
    if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
        PL_dowarn |= G_WARN_ONCE ;
    mXPUSHs(mask);
    XSRETURN(1);

void
enabled (...)
PPCODE:
    if (_chk("enabled", WNORMAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
fatal_enabled (...)
PPCODE:
    if (_chk("fatal_enabled", WFATAL, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warn (...)
PPCODE:
    if (_chk("warn", WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
warnif (...)
PPCODE:
    if (_chk("warnif", WNORMAL|WFATAL|WMESSAGE, ax))
        XSRETURN_YES;
    else
        XSRETURN_NO;

void
register_categories (...)
PREINIT:
    int i;
PPCODE:
    /* check if name is registered (const key).
       if not, add key and also add bit to Bits{all} and DeadBits{all} */
    for (i=0; i<items; i++) {
        SV *name = ST(i);
        char* n;
        struct Perl_warnings *w;
        struct Perl_warnings_dyn *wd;
        STRLEN l = SvCUR(name);
        if (!SvPOK(name)) continue;
        n = SvPVX(name);
        w = Perl_warnings_lookup(n, l);
        if (!w) { /* oops, a new category. Add to dynamic %_Bits */
            HV * const bith = get_hv("warnings::_Bits", GV_ADD);
            SV **bit;
            if (!(bit = hv_fetch(bith, n, l, FALSE))) {
                SV *last_bitsv = get_sv("warnings::LAST_BIT", 0);
                IV last_bit = SvIVX(last_bitsv);
                SV *bytes = get_sv("warnings::BYTES", 0);
                IV offset = last_bit + 1;
                SV *bits = newWSV("");
                SV *deadbits = newWSV("");
                char *b = SvPVX(bits);
                char *d = SvPVX(deadbits);
                b[ Off(last_bit) ] |= Bit(last_bit);
                d[ Off(offset) ]   |= Bit(offset);
                sv_catsv(bits, deadbits);
                sv_upgrade(bits, SVt_PVIV);
                SvIV_set(bits, offset);
                hv_store_ent(bith, name, bits, 0);
                /* now extend "all" */
                wd = (struct Perl_warnings_dyn *)Perl_warnings_lookup("all", 3);
                wd->bits[ Off(last_bit) ] |= Bit(last_bit);
                wd->deadbits[ Off(offset) ] |= Bit(offset);
                if (Off(last_bit) > SvIVX(bytes))
                  SvIV_set(bytes, Off(last_bit));

                SvIV_set(last_bitsv, offset + 1);
                if (DEBUG_v_TEST_)
                    Perl_deb("warnings::register_categories %s\n", n);
            }
        }
    }
    XSRETURN_UNDEF;

BOOT:
{
    GV *last_bit = gv_fetchpv("warnings::LAST_BIT", GV_ADD, SVt_IV);
    GV *bytes    = gv_fetchpv("warnings::BYTES", GV_ADD, SVt_IV);
    GvSV(last_bit) = newSViv(WARN_LAST_BIT);
    GvSV(bytes)    = newSViv(WARNsize);
}
